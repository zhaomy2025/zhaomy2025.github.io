---
title: Java泛型机制
date: 2025-03-12 14:31:25
tags:
  - Java
  - Java中级
  - Java泛型
categories:
  - Java
  - Java中级
---
Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示都替换为具体的类型，就像完全没有泛型一样。

# 为什么会引入泛型
泛型的本质是为了参数化类型，也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。引入泛型的意义在于：
1. 实现代码复用，适用于多种数据类型执行相同的代码
2. 提供类型约束，支持编译前的检查

# 泛型的基本使用
## 泛型类
在类名后面使用尖括号定义泛型，在变量和方法中使用定义的泛型，支持多元泛型。

## 泛型接口
在类名后面使用尖括号定义泛型，在变量和方法中使用定义的泛型，支持多元泛型。

## 泛型方法
在方法返回值前使用尖括号定义泛型。

**为什么要使用泛型方法呢？**
因为泛型类要在实例化的时候就指明类型，如果想换一种类型，就得重新new一次，不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。

**泛型方法和泛型类中（使用泛型的）方法不同点在于泛型定义的位置不同：**
- 泛型类的方法使用的泛型是在类名后定义
- 泛型方法的泛型在方法返回值前定义

## 泛型的上下限
```
<?> 无限制通配符
<? extends A> 类型可以是A或A的子类型
<? super A> 类型可以是A或A的父类型
```
使用规则：
- 生产者有上限：手机生产商可以生产各种品牌的手机
- 消费者有下限
- 如果既是生产者又是消费之，需要精确的类型

## 泛型代码简化
变量声明时定义泛型可以实现与完全使用泛型参数一样的效果，变量实例化时定义泛型没有效果。类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。

```java
ArrayList<String> list1 = new ArrayList(); // 变量声明时定义泛型有效
ArrayList list2 = new ArrayList<String>(); // 变量实例化时定义泛型无效
```

# 类型擦除
类型擦除（Type Erasure） 是 Java 泛型实现的一种机制，目的是为了兼容泛型引入之前的代码（即 Java 5 之前的非泛型代码）。类型擦除的核心思想是：在编译时检查泛型类型的安全性，但在运行时将泛型类型信息擦除，替换为原始类型（Raw Type）或边界类型（Bound Type）。

## 类型擦除的规则
1. 无界泛型替换为Object
2. 有界泛型根据子类替换原则取类型参数的最左边限定类型（即父类）
3. 为了保证编译的多态性，编译器会生成桥接方法，例如

```java
class MyClass implements Comparable<MyClass> {
    @Override
    public int compareTo(MyClass other) {
        return 0;
    }
}
```

编译后会生成一个桥接方法：

```java
public int compareTo(Object other) {
    return compareTo((MyClass) other);
}
```

## 类型擦除的影响
1. 运行时无法获取泛型类型信息
2. 无法创建泛型类型的实例
3. 无法使用基本类型作为泛型参数
4. 无法直接创建泛型数组

## 绕过类型擦除的限制
```java
public class MyClass<T> {
    private Class<T> type;

    public MyClass(Class<T> type) {
        this.type = type;
    }

    public T createInstance() throws Exception {
        return type.getDeclaredConstructor().newInstance();
    }
}
```

# 深入理解泛型
## 如何理解泛型类型不能实例化？
因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件。由于T 被擦除为 Object，如果可以 new T() 则就变成了 new Object()，失去了本意。如果确实需要实例化一个泛型，可以通过反射实现。

## 能不能采用具体的泛型类型初始化泛型数组？
不能，但是可以采用通配符的方式初始化泛型数组，因为对于通配符的方式最后取出数据是要做显式类型转换的，符合预期逻辑。

```java
List<?>[] lsa = new List<?>[10]; // OK, array of unbounded wildcard type.
Object o = lsa;
Object[] oa = (Object[]) o;
List<Integer> li = new ArrayList<Integer>();
li.add(new Integer(3));
oa[1] = li; // Correct.
Integer i = (Integer) lsa[1].get(0); // OK
```

## 泛型数组：如何正确的初始化泛型数组实例？

无论我们通过new ArrayList[10] 的形式还是通过泛型通配符的形式初始化泛型数组实例都是存在警告的，也就是说仅仅语法合格，运行时潜在的风险需要我们自己来承担，都不推荐。

使用泛型数组的场景应该尽量使用列表集合替换，非要创建泛型数组，可以通过反射来实现。

## 如何理解异常中使用泛型？
不能抛出也不能捕获泛型类的对象。无论使用无界泛型还是有界泛型，在编译时泛型信息全都会别擦除掉，变成原始类型，失去了使用泛型的意义。